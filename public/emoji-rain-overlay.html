<!DOCTYPE html>
<html lang="de">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Emoji Rain Overlay - TikTok Stream Tool</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            background: transparent;
            overflow: hidden;
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
        }

        #canvas-container {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
        }

        canvas {
            display: block;
            width: 100%;
            height: 100%;
        }

        .emoji-sprite {
            position: absolute;
            font-size: 48px;
            pointer-events: none;
            user-select: none;
            transform-origin: center;
            transition: opacity 0.5s ease;
        }

        .emoji-sprite.fading {
            opacity: 0;
        }

        /* Debug info (optional) */
        #debug-info {
            position: fixed;
            top: 10px;
            left: 10px;
            background: rgba(0,0,0,0.7);
            color: white;
            padding: 10px;
            border-radius: 5px;
            font-family: monospace;
            font-size: 12px;
            display: none;
            z-index: 1000;
        }
    </style>
</head>
<body>
    <div id="canvas-container"></div>
    <div id="debug-info"></div>

    <!-- Matter.js from CDN -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/matter-js/0.19.0/matter.min.js"></script>
    <script src="/socket.io/socket.io.js"></script>

    <script>
        // Matter.js aliases
        const Engine = Matter.Engine;
        const Render = Matter.Render;
        const World = Matter.World;
        const Bodies = Matter.Bodies;
        const Body = Matter.Body;
        const Events = Matter.Events;

        // Configuration
        let config = {
            enabled: true,
            width_px: 1280,
            height_px: 720,
            emoji_set: ["üíß","üíô","üíö","üíú","‚ù§Ô∏è","ü©µ","‚ú®","üåü","üî•","üéâ"],
            physics_gravity_y: 1.0,
            physics_air: 0.02,
            physics_friction: 0.1,
            physics_restitution: 0.6,
            physics_wind_strength: 0.0005,
            physics_wind_variation: 0.0003,
            emoji_min_size_px: 40,
            emoji_max_size_px: 80,
            emoji_rotation_speed: 0.05,
            emoji_lifetime_ms: 8000,
            emoji_fade_duration_ms: 1000,
            max_emojis_on_screen: 200,
            like_count_divisor: 10,
            like_min_emojis: 1,
            like_max_emojis: 20,
            gift_base_emojis: 3,
            gift_coin_multiplier: 0.1,
            gift_max_emojis: 50
        };

        // State
        let engine, render;
        let socket;
        let emojis = []; // Track emoji bodies and DOM elements
        let windForce = 0;
        let debugMode = false; // Set to true to show debug info

        // Initialize physics engine
        function initPhysics() {
            // Create engine
            engine = Engine.create({
                enableSleeping: false
            });

            // Set gravity
            engine.gravity.y = config.physics_gravity_y;

            // Create invisible boundaries
            const thickness = 100;
            const ground = Bodies.rectangle(
                config.width_px / 2,
                config.height_px + thickness / 2,
                config.width_px + thickness * 2,
                thickness,
                {
                    isStatic: true,
                    friction: config.physics_friction,
                    restitution: config.physics_restitution
                }
            );

            const leftWall = Bodies.rectangle(
                -thickness / 2,
                config.height_px / 2,
                thickness,
                config.height_px + thickness * 2,
                {
                    isStatic: true,
                    friction: config.physics_friction,
                    restitution: config.physics_restitution
                }
            );

            const rightWall = Bodies.rectangle(
                config.width_px + thickness / 2,
                config.height_px / 2,
                thickness,
                config.height_px + thickness * 2,
                {
                    isStatic: true,
                    friction: config.physics_friction,
                    restitution: config.physics_restitution
                }
            );

            World.add(engine.world, [ground, leftWall, rightWall]);

            // Run the engine
            Engine.run(engine);

            // Update loop
            requestAnimationFrame(updateLoop);
        }

        // Main update loop
        function updateLoop() {
            // Apply wind force to all emojis
            windForce += (Math.random() - 0.5) * config.physics_wind_variation;
            windForce = Math.max(-config.physics_wind_strength, Math.min(config.physics_wind_strength, windForce));

            emojis.forEach(emoji => {
                if (emoji.body) {
                    // Apply wind
                    Body.applyForce(emoji.body, emoji.body.position, {
                        x: windForce,
                        y: 0
                    });

                    // Apply air resistance
                    const velocity = emoji.body.velocity;
                    Body.setVelocity(emoji.body, {
                        x: velocity.x * (1 - config.physics_air),
                        y: velocity.y * (1 - config.physics_air)
                    });

                    // Update DOM element position and rotation
                    if (emoji.element) {
                        emoji.element.style.left = emoji.body.position.x + 'px';
                        emoji.element.style.top = emoji.body.position.y + 'px';

                        // Apply rotation
                        const rotation = emoji.body.angle + emoji.rotation;
                        emoji.rotation += config.emoji_rotation_speed;
                        emoji.element.style.transform = `translate(-50%, -50%) rotate(${rotation}rad)`;
                    }
                }

                // Check lifetime
                if (emoji.spawnTime && config.emoji_lifetime_ms > 0) {
                    const age = Date.now() - emoji.spawnTime;
                    if (age > config.emoji_lifetime_ms && !emoji.fading) {
                        fadeOutEmoji(emoji);
                    }
                }
            });

            // Remove faded emojis
            emojis = emojis.filter(emoji => {
                if (emoji.removed) {
                    return false;
                }
                return true;
            });

            // Limit max emojis
            while (emojis.length > config.max_emojis_on_screen) {
                const oldest = emojis[0];
                removeEmoji(oldest);
            }

            // Update debug info
            if (debugMode) {
                updateDebugInfo();
            }

            requestAnimationFrame(updateLoop);
        }

        // Spawn emoji
        function spawnEmoji(emoji, x, y, size) {
            // Normalize x position (0-1 to px)
            if (x >= 0 && x <= 1) {
                x = x * config.width_px;
            }

            // Create physics body (circle)
            const radius = size / 2;
            const body = Bodies.circle(x, y, radius, {
                friction: config.physics_friction,
                restitution: config.physics_restitution,
                density: 0.01,
                frictionAir: 0
            });

            // Add initial velocity (slight randomness)
            Body.setVelocity(body, {
                x: (Math.random() - 0.5) * 2,
                y: Math.random() * 2
            });

            // Add to world
            World.add(engine.world, body);

            // Create DOM element
            const element = document.createElement('div');
            element.className = 'emoji-sprite';
            element.textContent = emoji;
            element.style.fontSize = size + 'px';
            element.style.left = x + 'px';
            element.style.top = y + 'px';
            document.getElementById('canvas-container').appendChild(element);

            // Track emoji
            const emojiObj = {
                body: body,
                element: element,
                emoji: emoji,
                size: size,
                rotation: 0,
                spawnTime: Date.now(),
                fading: false,
                removed: false
            };

            emojis.push(emojiObj);

            return emojiObj;
        }

        // Fade out emoji
        function fadeOutEmoji(emoji) {
            if (emoji.fading) return;

            emoji.fading = true;
            emoji.element.classList.add('fading');

            setTimeout(() => {
                removeEmoji(emoji);
            }, config.emoji_fade_duration_ms);
        }

        // Remove emoji
        function removeEmoji(emoji) {
            if (emoji.removed) return;

            emoji.removed = true;

            // Remove from physics world
            if (emoji.body) {
                World.remove(engine.world, emoji.body);
                emoji.body = null;
            }

            // Remove DOM element
            if (emoji.element && emoji.element.parentNode) {
                emoji.element.parentNode.removeChild(emoji.element);
                emoji.element = null;
            }
        }

        // Handle spawn event from server
        function handleSpawnEvent(data) {
            if (!config.enabled) return;

            const count = data.count || 1;
            const emoji = data.emoji || getRandomEmoji();
            const x = data.x !== undefined ? data.x : Math.random();
            const y = data.y !== undefined ? data.y : 0;

            for (let i = 0; i < count; i++) {
                const size = config.emoji_min_size_px + Math.random() * (config.emoji_max_size_px - config.emoji_min_size_px);
                const offsetX = x + (Math.random() - 0.5) * 0.2; // Spread horizontally
                const offsetY = y - i * 5; // Stack vertically

                spawnEmoji(emoji, offsetX, offsetY, size);
            }

            console.log(`üåßÔ∏è Spawned ${count}x ${emoji} at (${x.toFixed(2)}, ${y})`);
        }

        // Get random emoji from config
        function getRandomEmoji() {
            if (config.emoji_set && config.emoji_set.length > 0) {
                return config.emoji_set[Math.floor(Math.random() * config.emoji_set.length)];
            }
            return '‚ùì';
        }

        // Calculate emoji count for likes
        function calculateLikeEmojis(likeCount) {
            const count = Math.floor(likeCount / config.like_count_divisor);
            return Math.max(config.like_min_emojis, Math.min(config.like_max_emojis, count));
        }

        // Calculate emoji count for gifts
        function calculateGiftEmojis(coins) {
            const count = config.gift_base_emojis + Math.floor(coins * config.gift_coin_multiplier);
            return Math.min(config.gift_max_emojis, count);
        }

        // Update debug info
        function updateDebugInfo() {
            const debug = document.getElementById('debug-info');
            debug.style.display = 'block';
            debug.innerHTML = `
                <strong>Emoji Rain Debug</strong><br>
                Emojis: ${emojis.length} / ${config.max_emojis_on_screen}<br>
                Wind: ${windForce.toFixed(6)}<br>
                Bodies: ${engine.world.bodies.length}<br>
                Enabled: ${config.enabled ? 'Yes' : 'No'}
            `;
        }

        // Load configuration from server
        async function loadConfig() {
            try {
                const response = await fetch('/api/emoji-rain/config');
                const data = await response.json();

                if (data.success && data.config) {
                    Object.assign(config, data.config);
                    console.log('‚úÖ Emoji rain config loaded', config);

                    // Update physics
                    if (engine) {
                        engine.gravity.y = config.physics_gravity_y;
                    }
                }
            } catch (error) {
                console.error('‚ùå Failed to load emoji rain config:', error);
            }
        }

        // Socket.IO setup
        function initSocket() {
            socket = io();

            socket.on('connect', () => {
                console.log('‚úÖ Connected to server');
            });

            // Listen for emoji rain spawn events
            socket.on('emoji-rain:spawn', (data) => {
                handleSpawnEvent(data);
            });

            // Listen for config updates
            socket.on('emoji-rain:config-update', (data) => {
                if (data.config) {
                    Object.assign(config, data.config);
                    console.log('üîÑ Config updated', config);

                    // Update physics
                    if (engine) {
                        engine.gravity.y = config.physics_gravity_y;
                    }
                }
            });

            // Listen for toggle
            socket.on('emoji-rain:toggle', (data) => {
                config.enabled = data.enabled;
                console.log('üîÑ Emoji rain ' + (data.enabled ? 'enabled' : 'disabled'));
            });

            // Test event for debugging
            socket.on('emoji-rain:test', () => {
                handleSpawnEvent({ count: 10 });
            });
        }

        // Initialize everything
        async function init() {
            console.log('üåßÔ∏è Initializing Emoji Rain Overlay...');

            // Load config first
            await loadConfig();

            // Initialize physics
            initPhysics();

            // Initialize socket
            initSocket();

            console.log('‚úÖ Emoji Rain Overlay ready!');
        }

        // Start when DOM is ready
        if (document.readyState === 'loading') {
            document.addEventListener('DOMContentLoaded', init);
        } else {
            init();
        }

        // Handle window resize
        window.addEventListener('resize', () => {
            // Could update canvas size here if needed
            console.log('Window resized');
        });

        // Enable debug mode with keyboard shortcut
        document.addEventListener('keydown', (e) => {
            if (e.key === 'd' && e.ctrlKey) {
                debugMode = !debugMode;
                if (!debugMode) {
                    document.getElementById('debug-info').style.display = 'none';
                }
                console.log('Debug mode: ' + debugMode);
            }
        });
    </script>
</body>
</html>
