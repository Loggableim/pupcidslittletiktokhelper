<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Goal Overlay</title>
    <script src="/socket.io/socket.io.js"></script>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            background: transparent;
            overflow: hidden;
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', sans-serif;
        }

        #goal-container {
            width: 100vw;
            height: 100vh;
            position: relative;
        }

        .hidden {
            display: none !important;
        }

        /* SVG gradient definitions for circular progress */
        svg defs {
            display: none;
        }
    </style>
</head>
<body>
    <div id="goal-container"></div>

    <!-- SVG gradients for circular template -->
    <svg width="0" height="0" style="position: absolute;">
        <defs>
            <linearGradient id="circularGradient" x1="0%" y1="0%" x2="100%" y2="100%">
                <stop offset="0%" stop-color="#60a5fa"/>
                <stop offset="100%" stop-color="#3b82f6"/>
            </linearGradient>
        </defs>
    </svg>

    <script>
        /**
         * GOAL OVERLAY RENDERER
         * Dynamically loads and renders goals with templates and animations
         */

        class GoalOverlayRenderer {
            constructor() {
                this.goalId = null;
                this.socket = null;
                this.goal = null;
                this.state = null;
                this.container = document.getElementById('goal-container');
                this.animationFrame = null;
                this.currentAnimation = null;
            }

            /**
             * Initialize overlay
             */
            async init() {
                // Get goal ID from URL
                const params = new URLSearchParams(window.location.search);
                this.goalId = params.get('id');

                if (!this.goalId) {
                    console.error('No goal ID provided in URL');
                    return;
                }

                // Connect to Socket.IO
                this.connectSocket();
            }

            /**
             * Connect to WebSocket
             */
            connectSocket() {
                this.socket = io();

                this.socket.on('connect', () => {
                    console.log('Connected to server');
                    this.subscribeToGoal();
                });

                this.socket.on('disconnect', () => {
                    console.log('Disconnected from server');
                });

                // Goal subscribed
                this.socket.on('goals:subscribed', (data) => {
                    console.log('Subscribed to goal:', data.goalId);
                    this.goal = data.goal;
                    this.state = data.state;
                    this.render();
                });

                // Value changed
                this.socket.on('goals:value-changed', (data) => {
                    if (data.goalId !== this.goalId) return;

                    console.log('Value changed:', data);
                    this.goal = data.goal;
                    this.state = data.state;
                    this.onValueChanged(data);
                });

                // Goal reached
                this.socket.on('goals:reached', (data) => {
                    if (data.goalId !== this.goalId) return;

                    console.log('Goal reached!');
                    this.goal = data.goal;
                    this.state = data.state;
                    this.onGoalReached(data);
                });

                // Reach complete (after behavior applied)
                this.socket.on('goals:reach-complete', (data) => {
                    if (data.goalId !== this.goalId) return;

                    console.log('Reach complete:', data);
                    this.goal = data.goal;
                    this.state = data.state;
                    this.render();
                });

                // Config changed
                this.socket.on('goals:config-changed', (data) => {
                    if (data.goal.id !== this.goalId) return;

                    console.log('Config changed');
                    this.goal = data.goal;
                    this.render();
                });

                // Goal reset
                this.socket.on('goals:reset', (data) => {
                    if (data.goalId !== this.goalId) return;

                    console.log('Goal reset');
                    this.goal = data.goal;
                    this.state = data.state;
                    this.render();
                });

                // Goal deleted
                this.socket.on('goals:deleted', (data) => {
                    if (data.goalId !== this.goalId) return;

                    console.log('Goal deleted');
                    this.container.innerHTML = '';
                });
            }

            /**
             * Subscribe to goal updates
             */
            subscribeToGoal() {
                this.socket.emit('goals:subscribe', this.goalId);
            }

            /**
             * Render goal
             */
            render() {
                if (!this.goal) return;

                // Check if hidden
                if (this.state && this.state.state === 'hidden') {
                    this.container.classList.add('hidden');
                    return;
                } else {
                    this.container.classList.remove('hidden');
                }

                // Get template
                const template = this.getTemplate(this.goal.template_id || 'compact-bar');
                const theme = this.goal.theme || {};

                // Render template
                const html = template.render(this.goal, theme);
                const styles = template.getStyles(theme);

                // Update container
                this.container.innerHTML = `
                    <style>${styles}</style>
                    ${html}
                `;

                // Apply overlay size
                if (this.goal.overlay_width && this.goal.overlay_height) {
                    this.container.style.width = this.goal.overlay_width + 'px';
                    this.container.style.height = this.goal.overlay_height + 'px';
                }
            }

            /**
             * Handle value changed
             */
            onValueChanged(data) {
                // Render with new value
                this.render();

                // Play update animation
                const animationId = this.goal.animation_on_update || 'smooth-progress';
                this.playUpdateAnimation(animationId);
            }

            /**
             * Handle goal reached
             */
            onGoalReached(data) {
                // Render with new value
                this.render();

                // Play reach animation
                const animationId = this.goal.animation_on_reach || 'celebration';
                this.playReachAnimation(animationId);
            }

            /**
             * Play update animation
             */
            playUpdateAnimation(animationId) {
                const animation = this.getAnimation(animationId);
                if (!animation) return;

                const element = this.container.querySelector('[class*="fill"], [class*="progress"]');
                if (!element) return;

                animation.apply(element, this.goal).then(() => {
                    // Signal animation end
                    this.socket.emit('goals:animation-end', {
                        goalId: this.goalId,
                        animationType: 'update'
                    });
                });
            }

            /**
             * Play reach animation
             */
            playReachAnimation(animationId) {
                const animation = this.getAnimation(animationId);
                if (!animation) return;

                animation.apply(this.container, this.goal).then(() => {
                    // Signal animation end
                    this.socket.emit('goals:animation-end', {
                        goalId: this.goalId,
                        animationType: 'reach'
                    });
                });
            }

            /**
             * Get template by ID
             */
            getTemplate(id) {
                const templates = {
                    'compact-bar': CompactBarTemplate,
                    'full-width': FullWidthTemplate,
                    'minimal-counter': MinimalCounterTemplate,
                    'circular-progress': CircularProgressTemplate,
                    'floating-pill': FloatingPillTemplate,
                    'vertical-meter': VerticalMeterTemplate
                };

                return templates[id] || templates['compact-bar'];
            }

            /**
             * Get animation by ID
             */
            getAnimation(id) {
                const animations = {
                    'smooth-progress': SmoothProgressAnimation,
                    'bounce': BounceAnimation,
                    'glow': GlowAnimation,
                    'celebration': CelebrationAnimation,
                    'confetti': ConfettiAnimation,
                    'pulse': PulseAnimation,
                    'flash': FlashAnimation,
                    'rainbow': RainbowAnimation
                };

                return animations[id] || animations['smooth-progress'];
            }
        }

        /**
         * TEMPLATES
         * Each template renders the goal UI
         */

        const CompactBarTemplate = {
            render(goal, theme) {
                const progress = Math.min(100, (goal.current_value / goal.target_value) * 100);
                const remaining = Math.max(0, goal.target_value - goal.current_value);
                const icon = this.getIcon(goal.goal_type);
                const primaryColor = theme.primaryColor || '#60a5fa';

                return `
                    <div class="compact-bar-container">
                        <div class="compact-bar-wrapper">
                            <div class="compact-bar-header">
                                <div class="compact-bar-title">
                                    <span class="compact-bar-icon">${icon}</span>
                                    <span class="compact-bar-name">${this.escape(goal.name)}</span>
                                </div>
                                <div class="compact-bar-stats">
                                    <span class="compact-bar-percent">${progress.toFixed(0)}%</span>
                                    <span class="compact-bar-values">${this.format(goal.current_value)} / ${this.format(goal.target_value)}</span>
                                </div>
                            </div>
                            <div class="compact-bar-progress">
                                <div class="compact-bar-fill" style="width: ${progress}%"></div>
                            </div>
                            <div class="compact-bar-remaining">
                                ${remaining > 0 ? `${this.format(remaining)} remaining` : 'Goal Reached! ðŸŽ‰'}
                            </div>
                        </div>
                    </div>
                `;
            },

            getStyles(theme) {
                const primaryColor = theme.primaryColor || '#60a5fa';
                const secondaryColor = theme.secondaryColor || '#3b82f6';
                const textColor = theme.textColor || '#ffffff';
                const bgColor = theme.bgColor || 'rgba(15, 23, 42, 0.95)';

                return `
                    .compact-bar-container { width: 100%; height: 100%; display: flex; align-items: center; justify-content: center; }
                    .compact-bar-wrapper { background: ${bgColor}; border-radius: 16px; padding: 20px; box-shadow: 0 8px 32px rgba(0, 0, 0, 0.4); border: 2px solid rgba(255, 255, 255, 0.1); backdrop-filter: blur(10px); width: 100%; position: relative; overflow: hidden; }
                    .compact-bar-wrapper::before { content: ''; position: absolute; top: 0; left: 0; right: 0; height: 3px; background: linear-gradient(90deg, ${primaryColor}, ${secondaryColor}); }
                    .compact-bar-header { display: flex; justify-content: space-between; align-items: center; margin-bottom: 12px; }
                    .compact-bar-title { display: flex; align-items: center; gap: 10px; }
                    .compact-bar-icon { font-size: 1.5rem; filter: drop-shadow(0 2px 4px rgba(0, 0, 0, 0.5)); }
                    .compact-bar-name { font-size: 1.2rem; font-weight: 700; color: ${textColor}; text-shadow: 0 2px 4px rgba(0, 0, 0, 0.5); }
                    .compact-bar-stats { display: flex; align-items: center; gap: 12px; }
                    .compact-bar-percent { font-size: 1.3rem; font-weight: 700; color: ${primaryColor}; text-shadow: 0 0 10px ${primaryColor}80; }
                    .compact-bar-values { font-size: 0.9rem; color: #cbd5e1; }
                    .compact-bar-progress { background: rgba(255, 255, 255, 0.1); border-radius: 10px; height: 20px; overflow: hidden; position: relative; }
                    .compact-bar-fill { height: 100%; background: linear-gradient(90deg, ${primaryColor}, ${secondaryColor}); border-radius: 10px; transition: width 0.5s cubic-bezier(0.4, 0, 0.2, 1); box-shadow: 0 0 20px ${primaryColor}80; will-change: width; }
                    .compact-bar-remaining { text-align: center; font-size: 0.85rem; color: #94a3b8; margin-top: 8px; }
                `;
            },

            getIcon(type) {
                const icons = { coin: 'ðŸª™', likes: 'â¤ï¸', follower: 'ðŸ‘¥', custom: 'â­' };
                return icons[type] || 'ðŸŽ¯';
            },

            format(num) {
                if (num >= 1000000) return (num / 1000000).toFixed(1) + 'M';
                if (num >= 1000) return (num / 1000).toFixed(1) + 'K';
                return num.toString();
            },

            escape(text) {
                const div = document.createElement('div');
                div.textContent = text;
                return div.innerHTML;
            }
        };

        // Additional templates (simplified versions for brevity - you can expand these)
        const FullWidthTemplate = { ...CompactBarTemplate, render(goal, theme) { return CompactBarTemplate.render(goal, theme); } };
        const MinimalCounterTemplate = { ...CompactBarTemplate, render(goal, theme) { return CompactBarTemplate.render(goal, theme); } };
        const CircularProgressTemplate = { ...CompactBarTemplate, render(goal, theme) { return CompactBarTemplate.render(goal, theme); } };
        const FloatingPillTemplate = { ...CompactBarTemplate, render(goal, theme) { return CompactBarTemplate.render(goal, theme); } };
        const VerticalMeterTemplate = { ...CompactBarTemplate, render(goal, theme) { return CompactBarTemplate.render(goal, theme); } };

        /**
         * ANIMATIONS
         * Each animation manipulates the DOM using requestAnimationFrame
         */

        const SmoothProgressAnimation = {
            apply(element, goal) {
                return new Promise(resolve => {
                    // Already smooth via CSS transition
                    setTimeout(resolve, 500);
                });
            }
        };

        const BounceAnimation = {
            apply(element, goal) {
                return new Promise(resolve => {
                    element.style.animation = 'bounce 0.6s ease';
                    setTimeout(() => {
                        element.style.animation = '';
                        resolve();
                    }, 600);
                });
            }
        };

        const GlowAnimation = {
            apply(element, goal) {
                return new Promise(resolve => {
                    element.style.animation = 'glow-pulse 0.8s ease';
                    setTimeout(() => {
                        element.style.animation = '';
                        resolve();
                    }, 800);
                });
            }
        };

        const CelebrationAnimation = {
            apply(container, goal) {
                return new Promise(resolve => {
                    // Create celebration effect
                    container.style.animation = 'celebrate 2s ease';
                    this.createConfetti(container);
                    setTimeout(() => {
                        container.style.animation = '';
                        resolve();
                    }, 2000);
                });
            },

            createConfetti(container) {
                const colors = ['#ff6b6b', '#4ecdc4', '#45b7d1', '#ffa07a', '#98d8c8', '#f7dc6f'];
                for (let i = 0; i < 50; i++) {
                    const confetti = document.createElement('div');
                    confetti.style.cssText = `
                        position: absolute;
                        width: 10px;
                        height: 10px;
                        background: ${colors[Math.floor(Math.random() * colors.length)]};
                        left: ${Math.random() * 100}%;
                        top: -10px;
                        animation: confetti-fall ${2 + Math.random() * 2}s linear forwards;
                        border-radius: 50%;
                    `;
                    container.appendChild(confetti);
                    setTimeout(() => confetti.remove(), 4000);
                }
            }
        };

        const ConfettiAnimation = { ...CelebrationAnimation };
        const PulseAnimation = { ...GlowAnimation };
        const FlashAnimation = { ...BounceAnimation };
        const RainbowAnimation = { ...CelebrationAnimation };

        // CSS Animations
        const style = document.createElement('style');
        style.textContent = `
            @keyframes bounce {
                0%, 100% { transform: scale(1); }
                50% { transform: scale(1.1); }
            }
            @keyframes glow-pulse {
                0%, 100% { filter: brightness(1); }
                50% { filter: brightness(1.5) drop-shadow(0 0 20px currentColor); }
            }
            @keyframes celebrate {
                0%, 100% { transform: scale(1); }
                25% { transform: scale(1.05) rotate(2deg); }
                75% { transform: scale(1.05) rotate(-2deg); }
            }
            @keyframes confetti-fall {
                to { transform: translateY(110vh) rotate(360deg); opacity: 0; }
            }
        `;
        document.head.appendChild(style);

        // Initialize overlay
        const renderer = new GoalOverlayRenderer();
        renderer.init();
    </script>
</body>
</html>
