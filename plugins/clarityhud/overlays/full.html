<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>ClarityHUD - Full Activity Overlay</title>
  <link href="https://fonts.googleapis.com/css2?family=Open+Sans:wght@400;600;700&family=OpenDyslexic&display=swap" rel="stylesheet">
  <style>
    * {
      margin: 0;
      padding: 0;
      box-sizing: border-box;
    }

    :root {
      --bg-color: rgba(0, 0, 0, 0.7);
      --text-color: #ffffff;
      --accent-color: #00d4ff;
      --chat-color: #4caf50;
      --follow-color: #ff5722;
      --share-color: #9c27b0;
      --gift-color: #ffc107;
      --sub-color: #f44336;
      --treasure-color: #00bcd4;
      --join-color: #607d8b;
      --border-radius: 8px;
      --spacing: 16px;
      --font-size: 18px;
      --line-height: 1.5;
      --outline-width: 2px;
      --outline-color: rgba(0, 0, 0, 0.8);
    }

    body {
      font-family: 'Open Sans', sans-serif;
      overflow: hidden;
      width: 100vw;
      height: 100vh;
      background: transparent;
      color: var(--text-color);
      font-size: var(--font-size);
      line-height: var(--line-height);
    }

    body.dyslexia-font {
      font-family: 'OpenDyslexic', sans-serif;
    }

    body.reduce-motion * {
      animation: none !important;
      transition: none !important;
    }

    #overlay-container {
      width: 100%;
      height: 100%;
      padding: var(--spacing);
      overflow: hidden;
    }

    /* Single Stream Layout */
    .layout-singleStream {
      display: flex;
      flex-direction: column;
      height: 100%;
    }

    .layout-singleStream .feed-container {
      flex: 1;
      overflow: hidden;
      display: flex;
      flex-direction: column;
    }

    .layout-singleStream.feed-direction-top .feed-container {
      flex-direction: column-reverse;
    }

    .layout-singleStream .event-item {
      padding: 12px 16px;
      margin: 6px 0;
      background: var(--bg-color);
      border-radius: var(--border-radius);
      display: flex;
      align-items: center;
      gap: 12px;
      min-height: 60px;
    }

    /* Structured Layout */
    .layout-structured {
      display: grid;
      gap: var(--spacing);
      height: 100%;
      grid-template-columns: repeat(auto-fit, minmax(300px, 1fr));
      grid-auto-rows: minmax(200px, 1fr);
    }

    @media (min-width: 1200px) {
      .layout-structured {
        grid-template-columns: repeat(3, 1fr);
      }
    }

    @media (min-width: 768px) and (max-width: 1199px) {
      .layout-structured {
        grid-template-columns: repeat(2, 1fr);
      }
    }

    .layout-structured .event-block {
      background: var(--bg-color);
      border-radius: var(--border-radius);
      padding: var(--spacing);
      overflow: hidden;
      display: flex;
      flex-direction: column;
    }

    .layout-structured .block-header {
      font-weight: 700;
      font-size: 1.2em;
      margin-bottom: 12px;
      padding-bottom: 8px;
      border-bottom: 2px solid currentColor;
      text-shadow: var(--outline-width) var(--outline-width) 0 var(--outline-color),
                   calc(-1 * var(--outline-width)) var(--outline-width) 0 var(--outline-color),
                   var(--outline-width) calc(-1 * var(--outline-width)) 0 var(--outline-color),
                   calc(-1 * var(--outline-width)) calc(-1 * var(--outline-width)) 0 var(--outline-color);
    }

    .layout-structured .block-content {
      flex: 1;
      overflow-y: auto;
      scrollbar-width: thin;
      scrollbar-color: var(--accent-color) transparent;
    }

    .layout-structured .block-content::-webkit-scrollbar {
      width: 6px;
    }

    .layout-structured .block-content::-webkit-scrollbar-thumb {
      background: var(--accent-color);
      border-radius: 3px;
    }

    .layout-structured .event-item {
      padding: 8px 12px;
      margin: 4px 0;
      border-left: 3px solid currentColor;
      background: rgba(255, 255, 255, 0.05);
      border-radius: 4px;
    }

    /* Adaptive Layout */
    .layout-adaptive {
      display: flex;
      flex-wrap: wrap;
      gap: var(--spacing);
      height: 100%;
      align-content: flex-start;
    }

    .layout-adaptive .event-block {
      background: var(--bg-color);
      border-radius: var(--border-radius);
      padding: var(--spacing);
      overflow: hidden;
      display: flex;
      flex-direction: column;
      min-width: 250px;
      max-height: 400px;
    }

    .layout-adaptive .event-block.flex-1 {
      flex: 1 1 100%;
    }

    .layout-adaptive .event-block.flex-2 {
      flex: 1 1 calc(50% - var(--spacing) / 2);
    }

    .layout-adaptive .event-block.flex-3 {
      flex: 1 1 calc(33.333% - var(--spacing) * 2 / 3);
    }

    .layout-adaptive .block-header {
      font-weight: 700;
      font-size: 1.1em;
      margin-bottom: 10px;
      padding-bottom: 6px;
      border-bottom: 2px solid currentColor;
      text-shadow: var(--outline-width) var(--outline-width) 0 var(--outline-color),
                   calc(-1 * var(--outline-width)) var(--outline-width) 0 var(--outline-color),
                   var(--outline-width) calc(-1 * var(--outline-width)) 0 var(--outline-color),
                   calc(-1 * var(--outline-width)) calc(-1 * var(--outline-width)) 0 var(--outline-color);
    }

    .layout-adaptive .block-content {
      flex: 1;
      overflow-y: auto;
      scrollbar-width: thin;
      scrollbar-color: var(--accent-color) transparent;
    }

    .layout-adaptive .block-content::-webkit-scrollbar {
      width: 6px;
    }

    .layout-adaptive .block-content::-webkit-scrollbar-thumb {
      background: var(--accent-color);
      border-radius: 3px;
    }

    .layout-adaptive .event-item {
      padding: 6px 10px;
      margin: 3px 0;
      border-left: 3px solid currentColor;
      background: rgba(255, 255, 255, 0.05);
      border-radius: 4px;
    }

    /* Event Item Styling */
    .event-item {
      opacity: 0;
      text-shadow: var(--outline-width) var(--outline-width) 0 var(--outline-color),
                   calc(-1 * var(--outline-width)) var(--outline-width) 0 var(--outline-color),
                   var(--outline-width) calc(-1 * var(--outline-width)) 0 var(--outline-color),
                   calc(-1 * var(--outline-width)) calc(-1 * var(--outline-width)) 0 var(--outline-color);
    }

    .event-icon {
      font-size: 1.5em;
      flex-shrink: 0;
      width: 1.5em;
      text-align: center;
      filter: drop-shadow(0 0 4px currentColor);
    }

    .event-username {
      font-weight: 600;
      flex-shrink: 0;
    }

    .event-type {
      opacity: 0.8;
      font-size: 0.9em;
      margin-left: 8px;
    }

    .event-message {
      flex: 1;
      word-wrap: break-word;
      overflow-wrap: break-word;
    }

    .event-gift-info {
      font-size: 0.85em;
      opacity: 0.9;
      margin-left: 8px;
    }

    /* Event Type Colors */
    .event-chat { color: var(--chat-color); }
    .event-follow { color: var(--follow-color); }
    .event-share { color: var(--share-color); }
    .event-gift { color: var(--gift-color); }
    .event-sub { color: var(--sub-color); }
    .event-treasure { color: var(--treasure-color); }
    .event-join { color: var(--join-color); }

    /* Accessibility Modes */
    body.night-mode {
      --bg-color: rgba(0, 0, 0, 0.9);
      --text-color: #e0e0e0;
    }

    body.day-mode {
      --bg-color: rgba(255, 255, 255, 0.9);
      --text-color: #000000;
      --outline-color: rgba(255, 255, 255, 0.8);
    }

    body.high-contrast {
      --bg-color: #000000;
      --text-color: #ffffff;
      --outline-color: #000000;
      --chat-color: #00ff00;
      --follow-color: #ff0000;
      --share-color: #ff00ff;
      --gift-color: #ffff00;
      --sub-color: #ff6600;
      --treasure-color: #00ffff;
      --join-color: #ffffff;
    }

    body.colorblind-safe {
      --chat-color: #0173b2;
      --follow-color: #de8f05;
      --share-color: #cc78bc;
      --gift-color: #ece133;
      --sub-color: #ca9161;
      --treasure-color: #029e73;
      --join-color: #949494;
    }

    body.vision-impaired {
      --font-size: 24px;
      --spacing: 24px;
      --outline-width: 3px;
    }

    body.vision-impaired .event-icon {
      font-size: 2em;
    }

    body.vision-impaired .block-header {
      font-size: 1.5em;
    }

    /* Loading State */
    .loading {
      display: flex;
      align-items: center;
      justify-content: center;
      height: 100%;
      color: var(--text-color);
      font-size: 1.2em;
      text-shadow: var(--outline-width) var(--outline-width) 0 var(--outline-color),
                   calc(-1 * var(--outline-width)) var(--outline-width) 0 var(--outline-color),
                   var(--outline-width) calc(-1 * var(--outline-width)) 0 var(--outline-color),
                   calc(-1 * var(--outline-width)) calc(-1 * var(--outline-width)) 0 var(--outline-color);
    }

    /* Hide scrollbar for clean VR experience */
    .feed-container::-webkit-scrollbar {
      width: 0;
      display: none;
    }

    .feed-container {
      scrollbar-width: none;
    }
  </style>
</head>
<body>
  <div id="overlay-container">
    <div class="loading">Connecting to ClarityHUD...</div>
  </div>

  <!-- Socket.io -->
  <script src="/socket.io/socket.io.js"></script>

  <!-- Libraries -->
  <script src="/plugins/clarityhud/lib/animations.js"></script>
  <script src="/plugins/clarityhud/lib/layout-engine.js"></script>

  <script>
    // ==================== STATE MANAGEMENT ====================
    const STATE = {
      settings: {},
      events: {
        chat: [],
        follow: [],
        share: [],
        gift: [],
        sub: [],
        treasure: [],
        join: []
      },
      layoutEngine: null,
      animationRegistry: null,
      animationRenderer: null,
      socket: null,
      container: null,
      isInitialized: false
    };

    // Event type configuration
    const EVENT_TYPES = {
      chat: { icon: 'ðŸ’¬', label: 'Chat', colorClass: 'event-chat' },
      follow: { icon: 'â¤ï¸', label: 'Followed', colorClass: 'event-follow' },
      share: { icon: 'ðŸ”„', label: 'Shared', colorClass: 'event-share' },
      gift: { icon: 'ðŸŽ', label: 'Gift', colorClass: 'event-gift' },
      sub: { icon: 'â­', label: 'Subscribed', colorClass: 'event-sub' },
      treasure: { icon: 'ðŸ’Ž', label: 'Treasure', colorClass: 'event-treasure' },
      join: { icon: 'ðŸ‘‹', label: 'Joined', colorClass: 'event-join' }
    };

    // ==================== INITIALIZATION ====================
    async function init() {
      console.log('Initializing ClarityHUD Full Overlay...');

      STATE.container = document.getElementById('overlay-container');

      // Initialize animation system
      STATE.animationRegistry = new AnimationRegistry();
      STATE.animationRenderer = new AnimationRenderer(STATE.animationRegistry);

      // Load settings
      await loadSettings();

      // Initialize layout engine
      STATE.layoutEngine = new LayoutEngine(STATE.container, STATE.settings);

      // Connect to socket
      connectSocket();

      // Apply initial render
      render();

      STATE.isInitialized = true;
      console.log('ClarityHUD Full Overlay initialized successfully');
    }

    // ==================== SETTINGS ====================
    async function loadSettings() {
      try {
        const response = await fetch('/api/clarityhud/settings/full');
        const data = await response.json();

        if (data.success && data.settings) {
          STATE.settings = data.settings;
          applySettings();
        } else {
          // Use defaults
          STATE.settings = getDefaultSettings();
          applySettings();
        }
      } catch (error) {
        console.error('Error loading settings:', error);
        STATE.settings = getDefaultSettings();
        applySettings();
      }
    }

    function getDefaultSettings() {
      return {
        // Event toggles
        showChat: true,
        showFollows: true,
        showShares: true,
        showGifts: true,
        showSubs: true,
        showTreasureChests: true,
        showJoins: true,

        // Layout
        layoutMode: 'singleStream',
        feedDirection: 'top',
        maxLines: 50,

        // Styling
        fontSize: 18,
        backgroundColor: 'rgba(0, 0, 0, 0.7)',
        textColor: '#ffffff',

        // Animations
        animationIn: 'fade',
        animationOut: 'fade',
        animationSpeed: 'medium',

        // Accessibility
        nightMode: true,
        dayMode: false,
        highContrastMode: false,
        colorblindSafeMode: false,
        visionImpairedMode: false,
        reduceMotion: false,
        dyslexiaFont: false,
        accessibilityPreset: 'none'
      };
    }

    function applySettings() {
      const s = STATE.settings;
      const root = document.documentElement;
      const body = document.body;

      // Apply accessibility preset first
      if (s.accessibilityPreset && s.accessibilityPreset !== 'none') {
        applyAccessibilityPreset(s.accessibilityPreset);
      } else {
        // Apply individual accessibility settings
        body.classList.toggle('night-mode', s.nightMode);
        body.classList.toggle('day-mode', s.dayMode);
        body.classList.toggle('high-contrast', s.highContrastMode);
        body.classList.toggle('colorblind-safe', s.colorblindSafeMode);
        body.classList.toggle('vision-impaired', s.visionImpairedMode);
        body.classList.toggle('reduce-motion', s.reduceMotion);
        body.classList.toggle('dyslexia-font', s.dyslexiaFont);
      }

      // Apply style settings
      if (s.fontSize) {
        root.style.setProperty('--font-size', `${s.fontSize}px`);
      }
      if (s.backgroundColor) {
        root.style.setProperty('--bg-color', s.backgroundColor);
      }
      if (s.textColor) {
        root.style.setProperty('--text-color', s.textColor);
      }

      console.log('Settings applied:', s);
    }

    function applyAccessibilityPreset(preset) {
      const body = document.body;

      // Clear all accessibility classes
      body.classList.remove('night-mode', 'day-mode', 'high-contrast',
                           'colorblind-safe', 'vision-impaired', 'reduce-motion', 'dyslexia-font');

      switch (preset) {
        case 'vr-optimized':
          body.classList.add('night-mode', 'vision-impaired');
          STATE.settings.fontSize = 24;
          break;
        case 'low-vision':
          body.classList.add('high-contrast', 'vision-impaired', 'dyslexia-font');
          STATE.settings.fontSize = 28;
          break;
        case 'colorblind':
          body.classList.add('colorblind-safe', 'night-mode');
          break;
        case 'motion-sensitive':
          body.classList.add('reduce-motion', 'night-mode');
          STATE.settings.animationIn = 'none';
          STATE.settings.animationOut = 'none';
          break;
        case 'dyslexia':
          body.classList.add('dyslexia-font', 'night-mode');
          STATE.settings.fontSize = 20;
          break;
      }
    }

    // ==================== SOCKET CONNECTION ====================
    function connectSocket() {
      STATE.socket = io();

      STATE.socket.on('connect', () => {
        console.log('Connected to server');
      });

      STATE.socket.on('disconnect', () => {
        console.log('Disconnected from server');
      });

      // Listen for settings updates
      STATE.socket.on('clarityhud.settings.full', (newSettings) => {
        console.log('Received settings update:', newSettings);
        STATE.settings = newSettings;
        applySettings();
        if (STATE.layoutEngine) {
          STATE.layoutEngine.updateSettings(STATE.settings);
        }
        render();
      });

      // Listen for event updates
      STATE.socket.on('clarityhud.update.chat', (data) => {
        if (STATE.settings.showChat) {
          addEvent('chat', data);
        }
      });

      STATE.socket.on('clarityhud.update.follow', (data) => {
        if (STATE.settings.showFollows) {
          addEvent('follow', data);
        }
      });

      STATE.socket.on('clarityhud.update.share', (data) => {
        if (STATE.settings.showShares) {
          addEvent('share', data);
        }
      });

      STATE.socket.on('clarityhud.update.gift', (data) => {
        if (STATE.settings.showGifts) {
          addEvent('gift', data);
        }
      });

      STATE.socket.on('clarityhud.update.subscribe', (data) => {
        if (STATE.settings.showSubs) {
          addEvent('sub', data);
        }
      });

      STATE.socket.on('clarityhud.update.treasure', (data) => {
        if (STATE.settings.showTreasureChests) {
          addEvent('treasure', data);
        }
      });

      STATE.socket.on('clarityhud.update.join', (data) => {
        if (STATE.settings.showJoins) {
          addEvent('join', data);
        }
      });
    }

    // ==================== EVENT MANAGEMENT ====================
    function addEvent(type, data) {
      const event = {
        type,
        data,
        timestamp: Date.now(),
        id: `${type}_${Date.now()}_${Math.random()}`
      };

      STATE.events[type].unshift(event);

      // Enforce max lines per type
      const maxLines = STATE.settings.maxLines || 50;
      if (STATE.events[type].length > maxLines) {
        STATE.events[type] = STATE.events[type].slice(0, maxLines);
      }

      // Trigger render
      renderEvent(event);
    }

    // ==================== RENDERING ====================
    function render() {
      const mode = STATE.settings.layoutMode || 'singleStream';

      // Clear container
      STATE.container.innerHTML = '';
      STATE.container.className = `layout-${mode}`;

      if (STATE.settings.feedDirection === 'top') {
        STATE.container.classList.add('feed-direction-top');
      }

      if (mode === 'singleStream') {
        renderSingleStream();
      } else if (mode === 'structured') {
        renderStructured();
      } else if (mode === 'adaptive') {
        renderAdaptive();
      }
    }

    function renderSingleStream() {
      const feedContainer = document.createElement('div');
      feedContainer.className = 'feed-container';
      STATE.container.appendChild(feedContainer);

      // Combine all events into single feed
      const allEvents = [];
      for (const type in STATE.events) {
        if (STATE.settings[`show${capitalize(type === 'sub' ? 'subs' : type === 'treasure' ? 'treasureChests' : type + 's')}`]) {
          allEvents.push(...STATE.events[type]);
        }
      }

      // Sort by timestamp (newest first or last based on feedDirection)
      allEvents.sort((a, b) => {
        return STATE.settings.feedDirection === 'top' ?
          b.timestamp - a.timestamp :
          a.timestamp - b.timestamp;
      });

      // Render events
      allEvents.slice(0, STATE.settings.maxLines || 50).forEach(event => {
        const element = createEventElement(event, 'singleStream');
        feedContainer.appendChild(element);
        animateElement(element, 'in', true);
      });
    }

    function renderStructured() {
      const eventTypes = ['chat', 'follow', 'share', 'gift', 'sub', 'treasure', 'join'];

      eventTypes.forEach(type => {
        const settingKey = `show${capitalize(type === 'sub' ? 'subs' : type === 'treasure' ? 'treasureChests' : type + 's')}`;
        if (!STATE.settings[settingKey]) return;

        const block = document.createElement('div');
        block.className = 'event-block';

        const header = document.createElement('div');
        header.className = `block-header ${EVENT_TYPES[type].colorClass}`;
        header.textContent = `${EVENT_TYPES[type].icon} ${EVENT_TYPES[type].label}`;
        block.appendChild(header);

        const content = document.createElement('div');
        content.className = 'block-content';
        content.dataset.type = type;
        block.appendChild(content);

        // Add events
        STATE.events[type].forEach(event => {
          const element = createEventElement(event, 'structured');
          content.appendChild(element);
          animateElement(element, 'in', true);
        });

        STATE.container.appendChild(block);
      });
    }

    function renderAdaptive() {
      const eventTypes = ['chat', 'follow', 'share', 'gift', 'sub', 'treasure', 'join'];
      const activeTypes = eventTypes.filter(type => {
        const settingKey = `show${capitalize(type === 'sub' ? 'subs' : type === 'treasure' ? 'treasureChests' : type + 's')}`;
        return STATE.settings[settingKey] && STATE.events[type].length > 0;
      });

      // Determine flex class based on number of active types
      let flexClass = 'flex-1';
      if (activeTypes.length === 2) {
        flexClass = 'flex-2';
      } else if (activeTypes.length >= 3) {
        flexClass = 'flex-3';
      }

      activeTypes.forEach(type => {
        const block = document.createElement('div');
        block.className = `event-block ${flexClass}`;

        const header = document.createElement('div');
        header.className = `block-header ${EVENT_TYPES[type].colorClass}`;
        header.textContent = `${EVENT_TYPES[type].icon} ${EVENT_TYPES[type].label}`;
        block.appendChild(header);

        const content = document.createElement('div');
        content.className = 'block-content';
        content.dataset.type = type;
        block.appendChild(content);

        // Add events
        const maxEventsPerBlock = Math.floor((STATE.settings.maxLines || 50) / Math.max(activeTypes.length, 1));
        STATE.events[type].slice(0, maxEventsPerBlock).forEach(event => {
          const element = createEventElement(event, 'adaptive');
          content.appendChild(element);
          animateElement(element, 'in', true);
        });

        STATE.container.appendChild(block);
      });
    }

    function renderEvent(event) {
      const mode = STATE.settings.layoutMode || 'singleStream';

      if (mode === 'singleStream') {
        // Add to feed
        const feedContainer = STATE.container.querySelector('.feed-container');
        if (feedContainer) {
          const element = createEventElement(event, mode);

          if (STATE.settings.feedDirection === 'top') {
            feedContainer.insertBefore(element, feedContainer.firstChild);
          } else {
            feedContainer.appendChild(element);
          }

          animateElement(element, 'in');

          // Remove old events if exceeding max
          const allItems = feedContainer.querySelectorAll('.event-item');
          if (allItems.length > (STATE.settings.maxLines || 50)) {
            const toRemove = allItems[STATE.settings.feedDirection === 'top' ? allItems.length - 1 : 0];
            animateElement(toRemove, 'out').then(() => {
              toRemove.remove();
            });
          }
        }
      } else {
        // Find the appropriate block
        const blockContent = STATE.container.querySelector(`.block-content[data-type="${event.type}"]`);
        if (blockContent) {
          const element = createEventElement(event, mode);
          blockContent.insertBefore(element, blockContent.firstChild);
          animateElement(element, 'in');

          // Remove old events if exceeding max
          const items = blockContent.querySelectorAll('.event-item');
          const maxPerBlock = mode === 'adaptive' ?
            Math.floor((STATE.settings.maxLines || 50) / Math.max(getActiveTypeCount(), 1)) :
            (STATE.settings.maxLines || 50);

          if (items.length > maxPerBlock) {
            const toRemove = items[items.length - 1];
            animateElement(toRemove, 'out').then(() => {
              toRemove.remove();
            });
          }
        }
      }
    }

    function createEventElement(event, layoutMode) {
      const element = document.createElement('div');
      element.className = `event-item ${EVENT_TYPES[event.type].colorClass}`;
      element.dataset.eventId = event.id;

      // Icon
      const icon = document.createElement('span');
      icon.className = 'event-icon';
      icon.textContent = EVENT_TYPES[event.type].icon;
      element.appendChild(icon);

      // Content varies by event type
      if (event.type === 'chat') {
        const username = document.createElement('span');
        username.className = 'event-username';
        username.textContent = event.data.username || 'Anonymous';
        element.appendChild(username);

        if (layoutMode === 'singleStream') {
          const type = document.createElement('span');
          type.className = 'event-type';
          type.textContent = `(${EVENT_TYPES[event.type].label})`;
          element.appendChild(type);
        }

        const message = document.createElement('span');
        message.className = 'event-message';
        message.textContent = event.data.message || '';
        element.appendChild(message);
      } else if (event.type === 'gift') {
        const username = document.createElement('span');
        username.className = 'event-username';
        username.textContent = event.data.username || 'Anonymous';
        element.appendChild(username);

        if (layoutMode === 'singleStream') {
          const type = document.createElement('span');
          type.className = 'event-type';
          type.textContent = `(${EVENT_TYPES[event.type].label})`;
          element.appendChild(type);
        }

        const giftInfo = document.createElement('span');
        giftInfo.className = 'event-gift-info';
        giftInfo.textContent = event.data.giftName ?
          `${event.data.giftName}${event.data.coins ? ` (${event.data.coins} coins)` : ''}` :
          (event.data.coins ? `${event.data.coins} coins` : 'sent a gift');
        element.appendChild(giftInfo);
      } else {
        // Standard event (follow, share, sub, treasure, join)
        const username = document.createElement('span');
        username.className = 'event-username';
        username.textContent = event.data.username || 'Anonymous';
        element.appendChild(username);

        if (layoutMode === 'singleStream') {
          const type = document.createElement('span');
          type.className = 'event-type';
          type.textContent = `(${EVENT_TYPES[event.type].label})`;
          element.appendChild(type);
        }
      }

      return element;
    }

    function animateElement(element, direction, skipAnimation = false) {
      if (!element || !STATE.animationRenderer) {
        return Promise.resolve();
      }

      if (skipAnimation || STATE.settings.reduceMotion || STATE.settings.animationIn === 'none') {
        element.style.opacity = '1';
        return Promise.resolve();
      }

      const animationType = direction === 'in' ?
        (STATE.settings.animationIn || 'fade') :
        (STATE.settings.animationOut || 'fade');

      const speed = STATE.settings.animationSpeed || 'medium';

      if (direction === 'in') {
        return STATE.animationRenderer.animateIn(element, animationType, speed);
      } else {
        return STATE.animationRenderer.animateOut(element, animationType, speed);
      }
    }

    // ==================== UTILITY FUNCTIONS ====================
    function capitalize(str) {
      return str.charAt(0).toUpperCase() + str.slice(1);
    }

    function getActiveTypeCount() {
      const eventTypes = ['chat', 'follow', 'share', 'gift', 'sub', 'treasure', 'join'];
      return eventTypes.filter(type => {
        const settingKey = `show${capitalize(type === 'sub' ? 'subs' : type === 'treasure' ? 'treasureChests' : type + 's')}`;
        return STATE.settings[settingKey] && STATE.events[type].length > 0;
      }).length;
    }

    // ==================== INITIALIZE ON LOAD ====================
    window.addEventListener('DOMContentLoaded', init);
  </script>
</body>
</html>
