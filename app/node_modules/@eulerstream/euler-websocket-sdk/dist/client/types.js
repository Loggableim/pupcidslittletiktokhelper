"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.WebSocketOptionsSchema = exports.WebSocketFeatureFlags = exports.CloseMessageMap = exports.ClientCloseCode = void 0;
const zod_1 = require("zod");
const webcast_1 = require("../webcast");
const zod_extra_1 = require("../extras/zod-extra");
var ClientCloseCode;
(function (ClientCloseCode) {
    /**
     * Responding to a client's close request normally
     */
    ClientCloseCode[ClientCloseCode["NORMAL"] = 1000] = "NORMAL";
    /**
     * Error updating presence on connect, or upstream error on connect in the proxy.
     */
    ClientCloseCode[ClientCloseCode["INTERNAL_SERVER_ERROR"] = 1011] = "INTERNAL_SERVER_ERROR";
    /**
     * Error fetching the /webcast/fetch endpoint for the socket
     */
    ClientCloseCode[ClientCloseCode["WEBCAST_FETCH_ERROR"] = 4556] = "WEBCAST_FETCH_ERROR";
    /**
     * Error fetching the /webcast/room_info endpoint for the socket
     */
    ClientCloseCode[ClientCloseCode["ROOM_INFO_FETCH_ERROR"] = 4557] = "ROOM_INFO_FETCH_ERROR";
    /**
     * TikTok closed the connected unexpectedly.
     */
    ClientCloseCode[ClientCloseCode["TIKTOK_CLOSED_CONNECTION"] = 4500] = "TIKTOK_CLOSED_CONNECTION";
    /**
     * The account has too many connections.
     */
    ClientCloseCode[ClientCloseCode["TOO_MANY_CONNECTIONS"] = 4429] = "TOO_MANY_CONNECTIONS";
    /**
     * The client provided invalid options, such as an invalid uniqueId or JWT key.
     */
    ClientCloseCode[ClientCloseCode["INVALID_OPTIONS"] = 4400] = "INVALID_OPTIONS";
    /**
     * The requested streamer is not live.
     */
    ClientCloseCode[ClientCloseCode["NOT_LIVE"] = 4404] = "NOT_LIVE";
    /**
     * The TikTok stream ended.
     */
    ClientCloseCode[ClientCloseCode["STREAM_END"] = 4005] = "STREAM_END";
    /**
     * There were no messages in the timeout period, the WebSocket was assumed dead and closed.
     */
    ClientCloseCode[ClientCloseCode["NO_MESSAGES_TIMEOUT"] = 4006] = "NO_MESSAGES_TIMEOUT";
    /**
     * Invalid Auth
     */
    ClientCloseCode[ClientCloseCode["INVALID_AUTH"] = 4401] = "INVALID_AUTH";
    /**
     * Accessing a creator the JWT has no access to
     */
    ClientCloseCode[ClientCloseCode["NO_PERMISSION"] = 4403] = "NO_PERMISSION";
    /**
     * WebSocket exceeded 8 hour lifetime
     */
    ClientCloseCode[ClientCloseCode["MAX_LIFETIME_EXCEEDED"] = 4555] = "MAX_LIFETIME_EXCEEDED";
})(ClientCloseCode = exports.ClientCloseCode || (exports.ClientCloseCode = {}));
// Short descriptions that can be sent over WebSocket close reason
exports.CloseMessageMap = {
    [ClientCloseCode.ROOM_INFO_FETCH_ERROR]: "Error fetching /webcast/room_info",
    [ClientCloseCode.WEBCAST_FETCH_ERROR]: "Error fetching /webcast/fetch",
    [ClientCloseCode.INVALID_AUTH]: "Invalid auth",
    [ClientCloseCode.MAX_LIFETIME_EXCEEDED]: "Max lifetime exceeded",
    [ClientCloseCode.NO_PERMISSION]: "No permission",
    [ClientCloseCode.INTERNAL_SERVER_ERROR]: "Internal server error",
    [ClientCloseCode.TIKTOK_CLOSED_CONNECTION]: "TikTok closed the connection unexpectedly",
    [ClientCloseCode.TOO_MANY_CONNECTIONS]: "Too many concurrent connections",
    [ClientCloseCode.INVALID_OPTIONS]: "Invalid options provided",
    [ClientCloseCode.NOT_LIVE]: "Streamer is not live",
    [ClientCloseCode.STREAM_END]: "TikTok stream ended",
    [ClientCloseCode.NO_MESSAGES_TIMEOUT]: "No messages received in timeout period, closing WebSocket",
    [ClientCloseCode.NORMAL]: "Normal closure"
};
exports.WebSocketFeatureFlags = zod_1.z.object({
    /**
     * When enabled, the client will bundle multiple messages into a single event. This is more efficient
     * than sending messages individually.
     */
    bundleEvents: (0, zod_extra_1.coerceBoolean)({ default: true }),
    /**
     * When enabled, the client will act as a pass-through proxy for raw messages. You will lose out on
     * additional features like presence messages, but this will fit nicely into existing libraries.
     */
    rawMessages: (0, zod_extra_1.coerceBoolean)({ default: false }),
    /**
     * Whether to normalize uniqueIds in URL format, @uniqueId format, etc., or treat them as-is.
     */
    normalizeUniqueId: (0, zod_extra_1.coerceBoolean)({ default: true }),
    /**
     * When enabled, the client will calculate presence information for users in the room.
     * This enables us to give custom SyntheticJoinMessage and SyntheticLeaveMessage, a full presence system.
     */
    syntheticPresence: (0, zod_extra_1.coerceBoolean)({ default: false }),
    /**
     * Configures how long a user must be inactive before we send a SyntheticLeaveMessage.
     */
    syntheticPresenceLeaveAfter: (0, zod_extra_1.coerceNumber)({ default: 300, min: 60, max: 3600 }),
    /**
     * Configures how long we can wait with NO messages coming from TikTok before we assume the WebSocket
     * is dead and close it.
     */
    closeInactiveWebSocketAfter: (0, zod_extra_1.coerceNumber)({ default: 60, min: 30, max: 3600 }),
    /**
     * The TikTok protobuf schema version to use for decoding messages.
     */
    schemaVersion: zod_1.z.nativeEnum(webcast_1.SchemaVersion).default(webcast_1.SchemaVersion.v2),
    /**
     * Whether to add a "raw" entry including base64 encoded Protobuf with the JSON
     */
    includeRawBytes: (0, zod_extra_1.coerceBoolean)({ default: false }),
    /**
     * Whether to use the Enterprise Sign API infrastructure (recommended)
     */
    useEnterpriseApi: (0, zod_extra_1.coerceBoolean)({ default: false })
});
exports.WebSocketOptionsSchema = zod_1.z.object({
    uniqueId: zod_1.z.string(),
    jwtKey: zod_1.z.string().optional().nullable(),
    apiKey: zod_1.z.string().optional().nullable(),
    features: exports.WebSocketFeatureFlags.default({})
});
//# sourceMappingURL=types.js.map