import { z } from "zod";
import { DecodedData, SchemaVersion } from "../webcast";
export declare enum ClientCloseCode {
    /**
     * Responding to a client's close request normally
     */
    NORMAL = 1000,
    /**
     * Error updating presence on connect, or upstream error on connect in the proxy.
     */
    INTERNAL_SERVER_ERROR = 1011,
    /**
     * Error fetching the /webcast/fetch endpoint for the socket
     */
    WEBCAST_FETCH_ERROR = 4556,
    /**
     * Error fetching the /webcast/room_info endpoint for the socket
     */
    ROOM_INFO_FETCH_ERROR = 4557,
    /**
     * TikTok closed the connected unexpectedly.
     */
    TIKTOK_CLOSED_CONNECTION = 4500,
    /**
     * The account has too many connections.
     */
    TOO_MANY_CONNECTIONS = 4429,
    /**
     * The client provided invalid options, such as an invalid uniqueId or JWT key.
     */
    INVALID_OPTIONS = 4400,
    /**
     * The requested streamer is not live.
     */
    NOT_LIVE = 4404,
    /**
     * The TikTok stream ended.
     */
    STREAM_END = 4005,
    /**
     * There were no messages in the timeout period, the WebSocket was assumed dead and closed.
     */
    NO_MESSAGES_TIMEOUT = 4006,
    /**
     * Invalid Auth
     */
    INVALID_AUTH = 4401,
    /**
     * Accessing a creator the JWT has no access to
     */
    NO_PERMISSION = 4403,
    /**
     * WebSocket exceeded 8 hour lifetime
     */
    MAX_LIFETIME_EXCEEDED = 4555
}
export declare const CloseMessageMap: Record<ClientCloseCode, string>;
export declare const WebSocketFeatureFlags: z.ZodObject<{
    /**
     * When enabled, the client will bundle multiple messages into a single event. This is more efficient
     * than sending messages individually.
     */
    bundleEvents: z.ZodDefault<z.ZodEffects<z.ZodEnum<["true", "false", "1", "0"]>, boolean, "0" | "1" | "false" | "true">>;
    /**
     * When enabled, the client will act as a pass-through proxy for raw messages. You will lose out on
     * additional features like presence messages, but this will fit nicely into existing libraries.
     */
    rawMessages: z.ZodDefault<z.ZodEffects<z.ZodEnum<["true", "false", "1", "0"]>, boolean, "0" | "1" | "false" | "true">>;
    /**
     * Whether to normalize uniqueIds in URL format, @uniqueId format, etc., or treat them as-is.
     */
    normalizeUniqueId: z.ZodDefault<z.ZodEffects<z.ZodEnum<["true", "false", "1", "0"]>, boolean, "0" | "1" | "false" | "true">>;
    /**
     * When enabled, the client will calculate presence information for users in the room.
     * This enables us to give custom SyntheticJoinMessage and SyntheticLeaveMessage, a full presence system.
     */
    syntheticPresence: z.ZodDefault<z.ZodEffects<z.ZodEnum<["true", "false", "1", "0"]>, boolean, "0" | "1" | "false" | "true">>;
    /**
     * Configures how long a user must be inactive before we send a SyntheticLeaveMessage.
     */
    syntheticPresenceLeaveAfter: z.ZodEffects<z.ZodEffects<z.ZodEffects<z.ZodEffects<z.ZodDefault<z.ZodString>, string, string | undefined>, number, string | undefined>, number, string | undefined>, number, string | undefined>;
    /**
     * Configures how long we can wait with NO messages coming from TikTok before we assume the WebSocket
     * is dead and close it.
     */
    closeInactiveWebSocketAfter: z.ZodEffects<z.ZodEffects<z.ZodEffects<z.ZodEffects<z.ZodDefault<z.ZodString>, string, string | undefined>, number, string | undefined>, number, string | undefined>, number, string | undefined>;
    /**
     * The TikTok protobuf schema version to use for decoding messages.
     */
    schemaVersion: z.ZodDefault<z.ZodNativeEnum<typeof SchemaVersion>>;
    /**
     * Whether to add a "raw" entry including base64 encoded Protobuf with the JSON
     */
    includeRawBytes: z.ZodDefault<z.ZodEffects<z.ZodEnum<["true", "false", "1", "0"]>, boolean, "0" | "1" | "false" | "true">>;
    /**
     * Whether to use the Enterprise Sign API infrastructure (recommended)
     */
    useEnterpriseApi: z.ZodDefault<z.ZodEffects<z.ZodEnum<["true", "false", "1", "0"]>, boolean, "0" | "1" | "false" | "true">>;
}, "strip", z.ZodTypeAny, {
    bundleEvents: boolean;
    rawMessages: boolean;
    normalizeUniqueId: boolean;
    syntheticPresence: boolean;
    syntheticPresenceLeaveAfter: number;
    closeInactiveWebSocketAfter: number;
    schemaVersion: SchemaVersion;
    includeRawBytes: boolean;
    useEnterpriseApi: boolean;
}, {
    bundleEvents?: "0" | "1" | "false" | "true" | undefined;
    rawMessages?: "0" | "1" | "false" | "true" | undefined;
    normalizeUniqueId?: "0" | "1" | "false" | "true" | undefined;
    syntheticPresence?: "0" | "1" | "false" | "true" | undefined;
    syntheticPresenceLeaveAfter?: string | undefined;
    closeInactiveWebSocketAfter?: string | undefined;
    schemaVersion?: SchemaVersion | undefined;
    includeRawBytes?: "0" | "1" | "false" | "true" | undefined;
    useEnterpriseApi?: "0" | "1" | "false" | "true" | undefined;
}>;
export declare const WebSocketOptionsSchema: z.ZodObject<{
    uniqueId: z.ZodString;
    jwtKey: z.ZodNullable<z.ZodOptional<z.ZodString>>;
    apiKey: z.ZodNullable<z.ZodOptional<z.ZodString>>;
    features: z.ZodDefault<z.ZodObject<{
        /**
         * When enabled, the client will bundle multiple messages into a single event. This is more efficient
         * than sending messages individually.
         */
        bundleEvents: z.ZodDefault<z.ZodEffects<z.ZodEnum<["true", "false", "1", "0"]>, boolean, "0" | "1" | "false" | "true">>;
        /**
         * When enabled, the client will act as a pass-through proxy for raw messages. You will lose out on
         * additional features like presence messages, but this will fit nicely into existing libraries.
         */
        rawMessages: z.ZodDefault<z.ZodEffects<z.ZodEnum<["true", "false", "1", "0"]>, boolean, "0" | "1" | "false" | "true">>;
        /**
         * Whether to normalize uniqueIds in URL format, @uniqueId format, etc., or treat them as-is.
         */
        normalizeUniqueId: z.ZodDefault<z.ZodEffects<z.ZodEnum<["true", "false", "1", "0"]>, boolean, "0" | "1" | "false" | "true">>;
        /**
         * When enabled, the client will calculate presence information for users in the room.
         * This enables us to give custom SyntheticJoinMessage and SyntheticLeaveMessage, a full presence system.
         */
        syntheticPresence: z.ZodDefault<z.ZodEffects<z.ZodEnum<["true", "false", "1", "0"]>, boolean, "0" | "1" | "false" | "true">>;
        /**
         * Configures how long a user must be inactive before we send a SyntheticLeaveMessage.
         */
        syntheticPresenceLeaveAfter: z.ZodEffects<z.ZodEffects<z.ZodEffects<z.ZodEffects<z.ZodDefault<z.ZodString>, string, string | undefined>, number, string | undefined>, number, string | undefined>, number, string | undefined>;
        /**
         * Configures how long we can wait with NO messages coming from TikTok before we assume the WebSocket
         * is dead and close it.
         */
        closeInactiveWebSocketAfter: z.ZodEffects<z.ZodEffects<z.ZodEffects<z.ZodEffects<z.ZodDefault<z.ZodString>, string, string | undefined>, number, string | undefined>, number, string | undefined>, number, string | undefined>;
        /**
         * The TikTok protobuf schema version to use for decoding messages.
         */
        schemaVersion: z.ZodDefault<z.ZodNativeEnum<typeof SchemaVersion>>;
        /**
         * Whether to add a "raw" entry including base64 encoded Protobuf with the JSON
         */
        includeRawBytes: z.ZodDefault<z.ZodEffects<z.ZodEnum<["true", "false", "1", "0"]>, boolean, "0" | "1" | "false" | "true">>;
        /**
         * Whether to use the Enterprise Sign API infrastructure (recommended)
         */
        useEnterpriseApi: z.ZodDefault<z.ZodEffects<z.ZodEnum<["true", "false", "1", "0"]>, boolean, "0" | "1" | "false" | "true">>;
    }, "strip", z.ZodTypeAny, {
        bundleEvents: boolean;
        rawMessages: boolean;
        normalizeUniqueId: boolean;
        syntheticPresence: boolean;
        syntheticPresenceLeaveAfter: number;
        closeInactiveWebSocketAfter: number;
        schemaVersion: SchemaVersion;
        includeRawBytes: boolean;
        useEnterpriseApi: boolean;
    }, {
        bundleEvents?: "0" | "1" | "false" | "true" | undefined;
        rawMessages?: "0" | "1" | "false" | "true" | undefined;
        normalizeUniqueId?: "0" | "1" | "false" | "true" | undefined;
        syntheticPresence?: "0" | "1" | "false" | "true" | undefined;
        syntheticPresenceLeaveAfter?: string | undefined;
        closeInactiveWebSocketAfter?: string | undefined;
        schemaVersion?: SchemaVersion | undefined;
        includeRawBytes?: "0" | "1" | "false" | "true" | undefined;
        useEnterpriseApi?: "0" | "1" | "false" | "true" | undefined;
    }>>;
}, "strip", z.ZodTypeAny, {
    uniqueId: string;
    features: {
        bundleEvents: boolean;
        rawMessages: boolean;
        normalizeUniqueId: boolean;
        syntheticPresence: boolean;
        syntheticPresenceLeaveAfter: number;
        closeInactiveWebSocketAfter: number;
        schemaVersion: SchemaVersion;
        includeRawBytes: boolean;
        useEnterpriseApi: boolean;
    };
    jwtKey?: string | null | undefined;
    apiKey?: string | null | undefined;
}, {
    uniqueId: string;
    jwtKey?: string | null | undefined;
    apiKey?: string | null | undefined;
    features?: {
        bundleEvents?: "0" | "1" | "false" | "true" | undefined;
        rawMessages?: "0" | "1" | "false" | "true" | undefined;
        normalizeUniqueId?: "0" | "1" | "false" | "true" | undefined;
        syntheticPresence?: "0" | "1" | "false" | "true" | undefined;
        syntheticPresenceLeaveAfter?: string | undefined;
        closeInactiveWebSocketAfter?: string | undefined;
        schemaVersion?: SchemaVersion | undefined;
        includeRawBytes?: "0" | "1" | "false" | "true" | undefined;
        useEnterpriseApi?: "0" | "1" | "false" | "true" | undefined;
    } | undefined;
}>;
export type ParsedWebSocketOptions = Omit<z.infer<typeof WebSocketOptionsSchema>, 'features'> & {
    features: WebSocketFeatureFlagsType;
};
export type WebSocketFeatureFlagsType = z.infer<typeof WebSocketFeatureFlags>;
export type WebSocketOptions = Omit<ParsedWebSocketOptions, 'features'> & {
    features?: Partial<WebSocketFeatureFlagsType>;
};
export type ClientMessageBundle = {
    timestamp: number;
    messages: DecodedData[];
};
//# sourceMappingURL=types.d.ts.map