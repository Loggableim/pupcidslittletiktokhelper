{"version":3,"file":"proto-utils.js","sourceRoot":"","sources":["../../src/webcast/proto-utils.ts"],"names":[],"mappings":"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","sourcesContent":["import * as tiktokSchema from \"../webcast/schemas/tiktok-schema-v2\";\nimport {\n  MessageFns,\n  ProtoMessageFetchResult,\n  SchemaVersion,\n  User,\n  WebcastPushFrame,\n  WebcastPushFrameDecoder,\n  WebcastSchemas\n} from \"./schemas\";\nimport {BinaryWriter} from \"@bufbuild/protobuf/wire\";\nimport {gunzipSync} from \"fflate\";\nimport {ClientCloseCode, WebSocketFeatureFlagsType} from \"../client\";\n\n\n/** FUNCTION: Extract type T from MessageFns<T> **/\ntype ExtractType<T> = T extends MessageFns<infer U> ? U : never;\n\n/** FUNCTION: Strips the 'Decoder' suffix from a string **/\ntype StripDecoderSuffix<T> = T extends `${infer Name}Decoder` ? Name : never;\n\n/** FUNCTION: Extract only those message types that have a 'common' property **/\ntype FilterMessagesWithCommon<T> = { [K in keyof T]: T[K] extends { common: any } ? K : never }[keyof T];\n\n/** MAP: Property names in tiktokSchema file to types **/\ntype TikTokSchema = typeof tiktokSchema;\n\n/** MAP: Property names to T from ExtractType<T>. Includes 'nevers' that need to be filtered out  **/\ntype RawExtractedTypes = {\n  [K in keyof TikTokSchema]: ExtractType<TikTokSchema[K]>;\n};\n\n/** UNION: All keys in RawExtractedTypes that DON'T result in a \"never\" **/\ntype FilteredKeys = {\n  [K in keyof RawExtractedTypes]:\n  RawExtractedTypes[K] extends never ? never : K;\n}[keyof RawExtractedTypes];\n\n/** MAP: Names of decoders to the type T they decode **/\nexport type WebcastDecoderMap = { [K in FilteredKeys]: RawExtractedTypes[K]; };\n\n/** UNION: All decoder values (i.e. the Protobuf Message interfaces they decode into) **/\nexport type WebcastMessage = WebcastDecoderMap[keyof WebcastDecoderMap];\n\n/** UNION: All decoder names **/\nexport type WebcastDecoderName = keyof WebcastDecoderMap;\n\n/** MAP: Names of T to the type T **/\nexport type WebcastMessageMap = { [K in keyof WebcastDecoderMap as StripDecoderSuffix<K>]: WebcastDecoderMap[K] };\n\n/** UNION: All type names T **/\nexport type WebcastMessageName = keyof WebcastMessageMap;\n\n/** MAP: Only those messages with a 'common' property **/\nexport type WebcastEventMap = { [K in FilterMessagesWithCommon<WebcastMessageMap>]: WebcastMessageMap[K] };\n\n/** UNION: Names of ONLY Event messages (i.e. Top-Level messages) **/\nexport type WebcastEventName = keyof WebcastEventMap;\n\n/** UNION: Values of ONLY Event messages **/\nexport type WebcastEvent = WebcastEventMap[keyof WebcastEventMap];\n\nexport type RoomInfoEvent = {\n  type: 'roomInfo',\n  data: Record<string, any>\n}\n\nexport type TikTokConnectEvent = {\n  type: 'tiktok.connect',\n  data: {\n    agentId: string\n  }\n}\n\nexport type TikTokDisconnectEvent = {\n  type: 'tiktok.disconnect',\n  data: {\n    reason: ClientCloseCode\n  }\n}\n\nexport type TikTokRawBytes = {\n  type: 'tiktok.rawBytes',\n  data: {\n    raw: string\n  }\n}\n\nexport type WorkerInfoEvent = {\n  type: 'workerInfo',\n  data: {\n    webSocketId: string;\n    schemaVersion: SchemaVersion;\n    features: WebSocketFeatureFlagsType\n  }\n}\n\nexport type PresenceRecord = {\n  user: Pick<\n      User,\n      'userId' | 'uniqueId' | 'nickname' | \"profilePicture\"\n  >,\n  firstSeen: number, // First event where they were seen\n  lastSeen: number // Last event where they were seen\n}\n\nexport type PresenceRegistry = Record<string, PresenceRecord>;\n\n\nexport type SyntheticLeaveMessage = {\n  type: 'SyntheticLeaveMessage',\n  data: PresenceRecord\n}\n\nexport type SyntheticJoinMessage = {\n  type: 'SyntheticJoinMessage',\n  data: PresenceRecord\n}\n\nexport type CustomData = RoomInfoEvent\n    | WorkerInfoEvent\n    | SyntheticJoinMessage\n    | SyntheticLeaveMessage\n    | TikTokConnectEvent\n    | TikTokDisconnectEvent\n    | TikTokRawBytes;\n\n/** UNION: All possible pairs of type to the data the type represents **/\nexport type DecodedData = {\n  [K in WebcastMessageName]: {\n    type: K;\n    data: WebcastMessageMap[K]\n  }\n}[WebcastMessageName] | CustomData;\n\nexport class NoSchemaFoundError extends Error {\n  constructor(message: string) {\n    super(message);\n    this.name = \"NoSchemaFoundError\";\n  }\n}\n\n\n/**\n * Deserialize ProtoMessageFetchResult and all nested messages\n *\n * @param protoBinary Binary\n * @param protoSchemaVersion Version to use when deserializing nested messages\n */\nfunction deserializeProtoMessageFetchResult(\n    protoBinary: Uint8Array,\n    protoSchemaVersion: SchemaVersion\n): ProtoMessageFetchResult {\n\n  // Always pull from Schema V2 for ProtoMessageFetchResult\n  const protoMessageFetchResult = WebcastSchemas[SchemaVersion.v2]\n      .ProtoMessageFetchResultDecoder\n      .decode(protoBinary);\n\n  const selectedSchema = WebcastSchemas[protoSchemaVersion];\n\n  for (const message of protoMessageFetchResult.messages || []) {\n\n    // Skip it if it's not in the schema\n    if (!selectedSchema[`${message.type}Decoder` as keyof typeof selectedSchema]) {\n      continue;\n    }\n\n    // Deserialize the message\n    try {\n      const messageType = message.type as WebcastMessageName;\n      const deserializedMessage: WebcastMessageMap[typeof messageType] = deserializeMessage(messageType as WebcastMessageName, message.payload, protoSchemaVersion);\n      message.decodedData = {type: messageType, data: deserializedMessage} as DecodedData\n    } catch (ex) {\n      console.info(`Failed to decode message type: ${message.type}`, ex);\n    }\n\n  }\n\n  return protoMessageFetchResult;\n}\n\n/**\n * Deserialize any message\n *\n * @param protoName Name of the proto to deserialize\n * @param protoBinary Binary for the deserialized proto\n * @param protoVersion Version of the proto schema to use\n */\nexport function deserializeMessage<T extends WebcastMessageName>(\n    protoName: T,\n    protoBinary: Uint8Array,\n    protoVersion: SchemaVersion\n): WebcastMessageMap[T] {\n\n  // These have nested message binaries in them, so we have a custom decoder ^.^\n  if (protoName === \"ProtoMessageFetchResult\") {\n    return deserializeProtoMessageFetchResult(protoBinary, protoVersion) as WebcastMessageMap[T]\n  }\n\n  // Get the decoder name\n  const decoderName: WebcastDecoderName = `${protoName}Decoder`;\n  const decoderFn = WebcastSchemas[protoVersion][decoderName as keyof typeof WebcastSchemas[SchemaVersion]] as MessageFns<WebcastMessageMap[T]>;\n\n  if (!decoderFn) {\n    throw new NoSchemaFoundError(`Invalid schema name: ${protoName}, not found in the Protobuf schema.`);\n  }\n\n  return decoderFn.decode(protoBinary);\n}\n\n\nexport type DecodedWebcastPushFrame = WebcastPushFrame & {\n  protoMessageFetchResult?: ProtoMessageFetchResult;\n}\n\nexport type RequiredDecodedWebcastPushFrame = Omit<DecodedWebcastPushFrame, 'protoMessageFetchResult'> & {\n  protoMessageFetchResult: ProtoMessageFetchResult;\n};\n\n\n/**\n * Deserialize a WebSocket message into a DecodedWebcastPushFrame\n *\n * @param protoBinary Binary message received from the WebSocket\n * @param protoSchemaVersion Version of the schema to use when deserializing nested messages\n */\nexport function deserializeWebSocketMessage(protoBinary: Uint8Array, protoSchemaVersion: SchemaVersion): DecodedWebcastPushFrame {\n\n  // Websocket messages are in a container which contains additional data\n  // Message type 'msg' represents a normal ProtoMessageFetchResult\n  const rawWebcastWebSocketMessage = WebcastPushFrameDecoder.decode(protoBinary); // Always with v2\n  let protoMessageFetchResult: ProtoMessageFetchResult | undefined = undefined;\n\n  if (rawWebcastWebSocketMessage.payloadEncoding === 'pb' && rawWebcastWebSocketMessage.payload) {\n    let binary: Uint8Array = rawWebcastWebSocketMessage.payload;\n\n    // Decompress binary (if gzip compressedâ€”which)\n    // It isn't in the WebSocket server to safe CPU but may be if users use this pkg to decompress manually for debugging\n    // https://www.rfc-editor.org/rfc/rfc1950.html\n    if (binary && binary.length > 2 && binary[0] === 0x1f && binary[1] === 0x8b && binary[2] === 0x08) {\n      rawWebcastWebSocketMessage.payload = gunzipSync(binary);\n    }\n\n    protoMessageFetchResult = deserializeMessage(\n        'ProtoMessageFetchResult',\n        rawWebcastWebSocketMessage.payload,\n        protoSchemaVersion\n    );\n\n\n  }\n\n  const decodedContainer: DecodedWebcastPushFrame = rawWebcastWebSocketMessage;\n  decodedContainer.protoMessageFetchResult = protoMessageFetchResult;\n  return decodedContainer;\n}\n\nexport function createBaseWebcastPushFrame(overrides: Partial<WebcastPushFrame>): BinaryWriter {\n  // Basically, we need to set it to \"0\" so that it DOES NOT send the field(s)\n  const undefinedNum: string = '0';\n\n  overrides = Object.fromEntries(\n      Object.entries(overrides).filter(([_, value]) => value !== undefined)\n  );\n\n  return WebcastPushFrameDecoder.encode(\n      {\n        seqId: undefinedNum,\n        logId: undefinedNum,\n        payloadEncoding: 'pb',\n        payloadType: 'msg',\n        payload: new Uint8Array(),\n        service: undefinedNum,\n        method: undefinedNum,\n        headers: {},\n        ...overrides\n      }\n  );\n\n}\n"]}