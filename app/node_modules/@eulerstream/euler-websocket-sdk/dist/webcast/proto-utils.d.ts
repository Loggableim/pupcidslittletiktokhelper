import * as tiktokSchema from "../webcast/schemas/tiktok-schema-v2";
import { MessageFns, ProtoMessageFetchResult, SchemaVersion, User, WebcastPushFrame } from "./schemas";
import { BinaryWriter } from "@bufbuild/protobuf/wire";
import { ClientCloseCode, WebSocketFeatureFlagsType } from "../client";
/** FUNCTION: Extract type T from MessageFns<T> **/
type ExtractType<T> = T extends MessageFns<infer U> ? U : never;
/** FUNCTION: Strips the 'Decoder' suffix from a string **/
type StripDecoderSuffix<T> = T extends `${infer Name}Decoder` ? Name : never;
/** FUNCTION: Extract only those message types that have a 'common' property **/
type FilterMessagesWithCommon<T> = {
    [K in keyof T]: T[K] extends {
        common: any;
    } ? K : never;
}[keyof T];
/** MAP: Property names in tiktokSchema file to types **/
type TikTokSchema = typeof tiktokSchema;
/** MAP: Property names to T from ExtractType<T>. Includes 'nevers' that need to be filtered out  **/
type RawExtractedTypes = {
    [K in keyof TikTokSchema]: ExtractType<TikTokSchema[K]>;
};
/** UNION: All keys in RawExtractedTypes that DON'T result in a "never" **/
type FilteredKeys = {
    [K in keyof RawExtractedTypes]: RawExtractedTypes[K] extends never ? never : K;
}[keyof RawExtractedTypes];
/** MAP: Names of decoders to the type T they decode **/
export type WebcastDecoderMap = {
    [K in FilteredKeys]: RawExtractedTypes[K];
};
/** UNION: All decoder values (i.e. the Protobuf Message interfaces they decode into) **/
export type WebcastMessage = WebcastDecoderMap[keyof WebcastDecoderMap];
/** UNION: All decoder names **/
export type WebcastDecoderName = keyof WebcastDecoderMap;
/** MAP: Names of T to the type T **/
export type WebcastMessageMap = {
    [K in keyof WebcastDecoderMap as StripDecoderSuffix<K>]: WebcastDecoderMap[K];
};
/** UNION: All type names T **/
export type WebcastMessageName = keyof WebcastMessageMap;
/** MAP: Only those messages with a 'common' property **/
export type WebcastEventMap = {
    [K in FilterMessagesWithCommon<WebcastMessageMap>]: WebcastMessageMap[K];
};
/** UNION: Names of ONLY Event messages (i.e. Top-Level messages) **/
export type WebcastEventName = keyof WebcastEventMap;
/** UNION: Values of ONLY Event messages **/
export type WebcastEvent = WebcastEventMap[keyof WebcastEventMap];
export type RoomInfoEvent = {
    type: 'roomInfo';
    data: Record<string, any>;
};
export type TikTokConnectEvent = {
    type: 'tiktok.connect';
    data: {
        agentId: string;
    };
};
export type TikTokDisconnectEvent = {
    type: 'tiktok.disconnect';
    data: {
        reason: ClientCloseCode;
    };
};
export type TikTokRawBytes = {
    type: 'tiktok.rawBytes';
    data: {
        raw: string;
    };
};
export type WorkerInfoEvent = {
    type: 'workerInfo';
    data: {
        webSocketId: string;
        schemaVersion: SchemaVersion;
        features: WebSocketFeatureFlagsType;
    };
};
export type PresenceRecord = {
    user: Pick<User, 'userId' | 'uniqueId' | 'nickname' | "profilePicture">;
    firstSeen: number;
    lastSeen: number;
};
export type PresenceRegistry = Record<string, PresenceRecord>;
export type SyntheticLeaveMessage = {
    type: 'SyntheticLeaveMessage';
    data: PresenceRecord;
};
export type SyntheticJoinMessage = {
    type: 'SyntheticJoinMessage';
    data: PresenceRecord;
};
export type CustomData = RoomInfoEvent | WorkerInfoEvent | SyntheticJoinMessage | SyntheticLeaveMessage | TikTokConnectEvent | TikTokDisconnectEvent | TikTokRawBytes;
/** UNION: All possible pairs of type to the data the type represents **/
export type DecodedData = {
    [K in WebcastMessageName]: {
        type: K;
        data: WebcastMessageMap[K];
    };
}[WebcastMessageName] | CustomData;
export declare class NoSchemaFoundError extends Error {
    constructor(message: string);
}
/**
 * Deserialize any message
 *
 * @param protoName Name of the proto to deserialize
 * @param protoBinary Binary for the deserialized proto
 * @param protoVersion Version of the proto schema to use
 */
export declare function deserializeMessage<T extends WebcastMessageName>(protoName: T, protoBinary: Uint8Array, protoVersion: SchemaVersion): WebcastMessageMap[T];
export type DecodedWebcastPushFrame = WebcastPushFrame & {
    protoMessageFetchResult?: ProtoMessageFetchResult;
};
export type RequiredDecodedWebcastPushFrame = Omit<DecodedWebcastPushFrame, 'protoMessageFetchResult'> & {
    protoMessageFetchResult: ProtoMessageFetchResult;
};
/**
 * Deserialize a WebSocket message into a DecodedWebcastPushFrame
 *
 * @param protoBinary Binary message received from the WebSocket
 * @param protoSchemaVersion Version of the schema to use when deserializing nested messages
 */
export declare function deserializeWebSocketMessage(protoBinary: Uint8Array, protoSchemaVersion: SchemaVersion): DecodedWebcastPushFrame;
export declare function createBaseWebcastPushFrame(overrides: Partial<WebcastPushFrame>): BinaryWriter;
export {};
//# sourceMappingURL=proto-utils.d.ts.map